#Тема 3.1-3.5. Алгоритмы. Работа в VS Code с алгоритмами сортировки и поиска
#• 1) сортировка выбором;
Анализ алгоритма: Сортировка выбором (Selection Sort)
Определение: Алгоритм разделяет массив на отсортированную и неотсортированную части. На каждом шаге находит минимальный элемент в неотсортированной части и меняет его местами с первым элементом этой части.
Анализ:
Внешний цикл выполняется n-1 раз
Внутренний цикл в худшем случае выполняется n-1, n-2, ... раз
Общее количество сравнений: n*(n-1)/2
Временная сложность: O(n²)
Почему O(n²): Два вложенных цикла, где каждый зависит от n. Внутренний цикл выполняется до n раз для каждого из n итераций внешнего цикла.
#• 2) сортировка обменом (пузырек);
Анализ алгоритма: Сортировка пузырьком (Bubble Sort)
Определение: Алгоритм многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.
Анализ:
В худшем случае требует n проходов по массиву
На каждом проходе выполняет n-1 сравнений
Общее количество сравнений: n*(n-1)/2
Временная сложность: O(n²)
Почему O(n²): Два вложенных цикла, каждый из которых зависит от n. Даже с оптимизацией в худшем случае остается квадратичной.
#• 3) сортировка вставками;
Анализ алгоритма: Сортировка вставками (Insertion Sort)
Определение: Алгоритм строит отсортированную последовательность, по одному элементу за раз, вставляя каждый новый элемент в правильную позицию.
Анализ:
В лучшем случае (уже отсортированный массив): O(n)
В худшем случае (обратно отсортированный): O(n²)
В среднем случае: O(n²)
Временная сложность: O(n²)
Почему O(n²): Для каждого из n элементов может потребоваться до n сдвигов в худшем случае.
• 4) сортировка слиянием;
Анализ алгоритма: Сортировка слиянием (Merge Sort)
Определение: Алгоритм "разделяй и властвуй", который рекурсивно делит массив пополам, сортирует каждую половину и затем сливает их.
Анализ:
Время разделения: O(log n)
Время слияния на каждом уровне: O(n)
Общее время: O(n log n)
Временная сложность: O(n log n)
Пространственная сложность: O(n)
Почему O(n log n): Массив делится пополам log n раз, и на каждом уровне выполняется O(n) операций слияния.
• 5) сортировка Шелла;
Анализ алгоритма: Сортировка Шелла (Shell Sort)
Определение: Улучшенная версия сортировки вставками, которая сортирует элементы на определенных расстояниях (промежутках), постепенно уменьшая промежуток.
Анализ:
Сложность зависит от выбора последовательности промежутков
В худшем случае: O(n²)
С последовательностью Кнута: O(n^(3/2))
В лучших случаях: O(n log n)
Временная сложность: O(n log n) до O(n²)
Почему такая сложность: Комбинация преимуществ сортировки вставками для почти отсортированных массивов и эффективного предварительного упорядочивания.
• 6) быстрая сортировка;
Анализ алгоритма: Быстрая сортировка (Quick Sort)
Определение: Алгоритм "разделяй и властвуй", который выбирает опорный элемент и разделяет массив на элементы меньше и больше опорного.
Анализ:
В среднем случае: O(n log n)
В худшем случае: O(n²) - когда массив уже отсортирован и выбран плохой опорный элемент
В лучшем случае: O(n log n)
Временная сложность: O(n log n) в среднем
Почему O(n log n): В среднем массив делится пополам log n раз, и на каждом уровне выполняется O(n) операций.
• 7) пирамидальная сортировка;
Анализ алгоритма: Пирамидальная сортировка (Heap Sort)
Определение: Алгоритм, который использует структуру данных "куча" (heap) для сортировки элементов.
Анализ:
Построение кучи: O(n)
Каждое извлечение максимума: O(log n)
Всего n извлечений: O(n log n)
Временная сложность: O(n log n)
Пространственная сложность: O(1)
Почему O(n log n): Построение кучи занимает O(n), и каждое из n извлечений занимает O(log n).
• 8) последовательный поиск;
Анализ алгоритма: Последовательный поиск (Linear Search)
Определение: Простейший алгоритм поиска, который проверяет каждый элемент последовательно до нахождения искомого.
Анализ:
В лучшем случае: O(1) - элемент первый
В худшем случае: O(n) - элемент последний или отсутствует
В среднем случае: O(n)
Временная сложность: O(n)
Пространственная сложность: O(1)
Почему O(n): В худшем случае требуется проверить все n элементов.
• 9) бинарный поиск;
Анализ алгоритма: Бинарный поиск (Binary Search)
Определение: Алгоритм поиска в отсортированном массиве путем многократного деления интервала поиска пополам.
Анализ:
На каждой итерации область поиска уменьшается вдвое
Максимальное количество итераций: log₂n
Временная сложность: O(log n)
Пространственная сложность: O(1)
Почему O(log n): На каждом шаге область поиска уменьшается вдвое, что дает логарифмическую сложность.
• 10) интерполирующий поиск;
Анализ алгоритма: Интерполирующий поиск (Interpolation Search)
Определение: Улучшенная версия бинарного поиска, которая предсказывает позицию искомого элемента на основе значений.
Анализ:
В лучшем случае (равномерное распределение): O(log log n)
В худшем случае (неравномерное распределение): O(n)
В среднем случае: O(log log n)
Временная сложность: O(log log n) до O(n)
Почему такая сложность: Использует информацию о распределении данных для более точного предсказания позиции.
• 11) Фибоначчи поиск,
Анализ алгоритма: Поиск Фибоначчи (Fibonacci Search)
Определение: Алгоритм поиска, использующий числа Фибоначчи для определения позиций сравнения.
Анализ:
Временная сложность: O(log n)
Как и бинарный поиск, но с другим коэффициентом
Меньше сравнений, чем бинарный поиск
Временная сложность: O(log n)
Пространственная сложность: O(1)
Почему O(log n): Использует свойства чисел Фибоначчи для деления массива в золотом сечении, что дает логарифмическую сложность.
